//
// BLACK - Bounded Ltl sAtisfiability ChecKer
//
// (C) 2022 Nicola Gigante
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef BLACK_LOGIC_FRAGMENTS_HPP_
#define BLACK_LOGIC_FRAGMENTS_HPP_

//
// This file defines the fragments and the namespaces exposed by the library.
// Everything declared before this file in `logic.hpp` have been declared in
// `black::logic::internal`, while here we re-export a selected number of
// names into the user-facing `black::logic` namespace
//
//

namespace black::logic::internal {
  class scope;
  class nest_scope_t;
  domain_ref make_domain(std::vector<variable>);
}

namespace black {

  //
  // The `black::logic` namespace contains all the user-facing names in
  // their generality, including all the fragments.
  //
  namespace logic {
    inline namespace common {
      using black::logic::internal::alphabet;
      using black::logic::internal::var_decl;
      using black::logic::internal::domain;
      using black::logic::internal::domain_ref;
      using black::logic::internal::make_domain;
      using black::logic::internal::scope;
      using black::logic::internal::nest_scope_t;
      using black::logic::internal::otherwise;
      using black::logic::internal::syntax_element;
      using black::logic::internal::fragment;
      using black::logic::internal::hierarchy;
      using black::logic::internal::storage_kind;
      using black::logic::internal::hierarchy_element;
      using black::logic::internal::syntax_list;
      using black::logic::internal::make_fragment;
      using black::logic::internal::make_singleton_fragment;
      using black::logic::internal::make_combined_fragment;
      using black::logic::internal::make_fragment_t;
      using black::logic::internal::make_singleton_fragment_t;
      using black::logic::internal::make_combined_fragment_t;
      using black::logic::internal::for_each_child;
      using black::logic::internal::for_each_child_deep;
      using black::logic::internal::has_any_element_of;
      using black::logic::internal::big_and;
      using black::logic::internal::big_or;
      using black::logic::internal::replace;
    }
    
    using black::logic::internal::only;

    //
    // These are three fragments useful for use with `only`
    //
    struct future : make_fragment_t<
      syntax_list<
        syntax_element::tomorrow,
        syntax_element::w_tomorrow,
        syntax_element::always,
        syntax_element::eventually,
        syntax_element::until,
        syntax_element::release,
        syntax_element::w_until,
        syntax_element::s_release
      >
    > { };

    struct past : make_fragment_t<
      syntax_list<
        syntax_element::yesterday,
        syntax_element::w_yesterday,
        syntax_element::once,
        syntax_element::historically,
        syntax_element::since,
        syntax_element::triggered
      >
    > { };

    struct temporal : make_combined_fragment_t<future, past> { };

    //
    // We include all the names generated by the hierarchy definition file.
    //
    #define declare_hierarchy(Base) \
      using black::logic::internal::Base;

    #define declare_storage_kind(Base, Storage) \
      using black::logic::internal::Storage;

    #define declare_hierarchy_element(Base, Storage, Element) \
      using black::logic::internal::Element;

    #include <black/internal/logic/hierarchy.hpp>
  }

  //
  // The `future`, `past` and `temporal` fragments make sense only in a few
  // namespaces.
  //
  namespace logic::fragments::LTL {
    using black::logic::future;
    using black::logic::past;
    using black::logic::temporal;
  }
  namespace logic::fragments::LTLP {
    using black::logic::future;
    using black::logic::past;
    using black::logic::temporal;
  }
  namespace logic::fragments::LTLFO {
    using black::logic::future;
    using black::logic::past;
    using black::logic::temporal;
  }
  namespace logic::fragments::LTLPFO {
    using black::logic::future;
    using black::logic::past;
    using black::logic::temporal;
  }
}

//
// Now we define the fragments. Here we define particular macros that enumerate
// all the `syntax_element`s included in the given fragment. These macros will
// be called in the right way later. Here, we treat this piece of code as a sort
// of declarative description of the fragments.
//
 
#define enum_elements_propositional(Element) \
  Element(boolean) \
  Element(proposition) \
  Element(negation) \
  Element(conjunction) \
  Element(disjunction) \
  Element(implication) \
  Element(iff)

#define enum_elements_FO(Element) \
  enum_elements_propositional(Element) \
  Element(atom) \
  Element(exists) \
  Element(forall) \
  Element(var_decl) \
  Element(constant) \
  Element(variable) \
  Element(application) \
  Element(negative) \
  Element(to_integer) \
  Element(to_real) \
  Element(subtraction) \
  Element(addition) \
  Element(multiplication) \
  Element(division) \
  Element(int_division) \
  Element(equal) \
  Element(distinct) \
  Element(less_than) \
  Element(less_than_equal) \
  Element(greater_than) \
  Element(greater_than_equal) \
  Element(integer) \
  Element(real) \
  Element(relation) \
  Element(function)

#define enum_elements_LTL(Element) \
  enum_elements_propositional(Element) \
  Element(tomorrow) \
  Element(w_tomorrow) \
  Element(always) \
  Element(eventually) \
  Element(until) \
  Element(release) \
  Element(w_until) \
  Element(s_release)

#define enum_elements_LTLP(Element) \
  enum_elements_LTL(Element) \
  Element(yesterday) \
  Element(w_yesterday) \
  Element(once) \
  Element(historically) \
  Element(since) \
  Element(triggered)

#define enum_elements_LTLFO(Element) \
  enum_elements_FO(Element) \
  enum_elements_LTL(Element) \
  Element(next) \
  Element(wnext)

#define enum_elements_LTLPFO(Element) \
  enum_elements_LTLFO(Element) \
  enum_elements_LTLP(Element) \
  Element(prev) \
  Element(wprev)

//
// By repeatedly including `declare_fragment.hpp` we actually declare the
// fragments and their namespaces
//
#define FRAGMENT propositional
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT FO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTL
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLP
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLFO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLPFO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT

//
// At the end, we import the namespace of the LTLPFO fragment, which is the most
// general we have right now, into the main `black` namespace, so that
// `black::formula` etc. refer to the most general fragment available.
//
namespace black {
  using namespace logic::fragments::LTLPFO;
}

#undef enum_elements_propositional
#undef enum_elements_FO
#undef enum_elements_LTL
#undef enum_elements_LTLP
#undef enum_elements_LTLFO
#undef enum_elements_LTLPFO

#endif // BLACK_LOGIC_FRAGMENTS_HPP_
