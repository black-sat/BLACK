//
// BLACK - Bounded Ltl sAtisfiability ChecKer
//
// (C) 2022 Nicola Gigante
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef BLACK_LOGIC_FRAGMENTS_HPP_
#define BLACK_LOGIC_FRAGMENTS_HPP_

//
// This file defines the fragments and the namespaces exposed by the library.
// Everything declared before this file in `logic.hpp` have been declared in
// `black::internal`, while here we re-export a selected number of
// names into the user-facing `black::logic` namespace
//
//

namespace black {

  //
  // The `black::logic` namespace contains all the user-facing names in
  // their generality, including all the fragments.
  //
  namespace logic {
    inline namespace common {
      using black::internal::logic::alphabet;
      using black::internal::logic::otherwise;
      using black::internal::logic::syntax_element;
      using black::internal::logic::fragment;
      using black::internal::logic::hierarchy;
      using black::internal::logic::storage_kind;
      using black::internal::logic::hierarchy_element;
      using black::internal::logic::make_fragment_t;
      using black::internal::logic::make_combined_fragment_t;
      using black::internal::logic::type_value;
      using black::internal::logic::for_each_child;
      using black::internal::logic::fragment_cast;
      using black::internal::logic::can_fragment_cast;
      using black::internal::logic::fragment_unsafe_cast;
    }
    
    using black::internal::logic::only;
    using black::internal::logic::quantifier_block;
    using black::internal::logic::exists_block;
    using black::internal::logic::forall_block;

    //
    // These are three fragments useful for use with `only`
    //
    struct Future : make_fragment_t<
      syntax_element::tomorrow,
      syntax_element::w_tomorrow,
      syntax_element::always,
      syntax_element::eventually,
      syntax_element::until,
      syntax_element::release
    > { };

    struct Past : make_fragment_t<
      syntax_element::yesterday,
      syntax_element::w_yesterday,
      syntax_element::once,
      syntax_element::historically,
      syntax_element::since,
      syntax_element::triggered
    > { };

    struct Temporal : make_combined_fragment_t<Future, Past> { };

    //
    // We include all the names generated by the hierarchy definition file.
    //
    #define declare_hierarchy(Base) \
      using black::internal::logic::Base;

    #define declare_storage_kind(Base, Storage) \
      using black::internal::logic::Storage;

    #define declare_hierarchy_element(Base, Storage, Element) \
      using black::internal::logic::Element;

    #include <black/internal/logic/hierarchy.hpp>
  }

  //
  // The `Future`, `Past` and `Temporal` fragments make sense only in a few
  // namespaces.
  //
  namespace LTL {
    using black::logic::Future;
    using black::logic::Past;
    using black::logic::Temporal;
  }
  namespace LTLP {
    using black::logic::Future;
    using black::logic::Past;
    using black::logic::Temporal;
  }
  namespace LTLFO {
    using black::logic::Future;
    using black::logic::Past;
    using black::logic::Temporal;
  }
  namespace LTLPFO {
    using black::logic::Future;
    using black::logic::Past;
    using black::logic::Temporal;
  }
}

//
// Now we define the fragments. Here we define particular macros that enumerate
// all the `syntax_element`s included in the given fragment. These macros will
// be called in the right way later. Here, we treat this piece of code as a sort
// of declarative description of the fragments.
//
 
#define enum_elements_Boolean(Element) \
  Element(boolean) \
  Element(proposition) \
  Element(negation) \
  Element(conjunction) \
  Element(disjunction) \
  Element(implication) \
  Element(iff)

#define enum_elements_FO(Element) \
  enum_elements_Boolean(Element) \
  Element(atom) \
  Element(exists) \
  Element(forall) \
  Element(constant) \
  Element(variable) \
  Element(application) \
  Element(negative) \
  Element(subtraction) \
  Element(addition) \
  Element(multiplication) \
  Element(division) \
  Element(equal) \
  Element(not_equal) \
  Element(less_than) \
  Element(less_than_equal) \
  Element(greater_than) \
  Element(greater_than_equal) \
  Element(integer) \
  Element(real) \
  Element(zero) \
  Element(one) \
  Element(relation) \
  Element(function)

#define enum_elements_LTL(Element) \
  enum_elements_Boolean(Element) \
  Element(tomorrow) \
  Element(w_tomorrow) \
  Element(always) \
  Element(eventually) \
  Element(until) \
  Element(release) \
  Element(w_until) \
  Element(s_release)

#define enum_elements_LTLP(Element) \
  enum_elements_LTL(Element) \
  Element(yesterday) \
  Element(w_yesterday) \
  Element(once) \
  Element(historically) \
  Element(since) \
  Element(triggered)

#define enum_elements_LTLFO(Element) \
  enum_elements_FO(Element) \
  enum_elements_LTL(Element) \
  Element(next) \
  Element(wnext)

#define enum_elements_LTLPFO(Element) \
  enum_elements_LTLFO(Element) \
  enum_elements_LTLP(Element) \
  Element(prev) \
  Element(wprev)

//
// By repeatedly including `declare_fragment.hpp` we actually declare the
// fragments and their namespaces
//
#define FRAGMENT Boolean
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT FO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTL
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLP
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLFO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT
#define FRAGMENT LTLPFO
#include <black/internal/logic/declare_fragment.hpp>
#undef FRAGMENT

//
// At the end, we import the namespace of the LTLPFO fragment, which is the most
// general we have right now, into the main `black` namespace, so that
// `black::formula` etc. refer to the most general fragment available.
//
namespace black {
  using namespace LTLPFO;
}

#undef enum_elements_Boolean
#undef enum_elements_FO
#undef enum_elements_LTL
#undef enum_elements_LTLP
#undef enum_elements_LTLFO
#undef enum_elements_LTLPFO

#endif // BLACK_LOGIC_FRAGMENTS_HPP_
