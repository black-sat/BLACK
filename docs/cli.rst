.. highlight:: console

Command-line interface
======================

BLACK's main interface to the user is the command-line tool ``black``. Here we
document its usage. For the input syntax accepted by the tool, look a the
:doc:`syntax` page.

Tutorial
--------

The main purpose of ``black`` is to tell you whether a given temporal logic
formula (see :doc:`logics`) is *satisfiable*. Let's suppose you have written
such a formula in the file ``spec.pltl``::

   $ cat spec.pltl
   !p & X !p & F p

Then, asking ``black`` about this formula is as easy as::

   $ black solve spec.pltl
   SAT

``black`` replies ``SAT`` on the standard output, so the formula is satisfiable.
Let us try an unsatisfiable formula::

   $ cat unsat-spec.pltl
   p & G(p -> q) & !q

   $ black solve spec.pltl
   UNSAT

If the filename is ``-``, ``black`` reads from the *standard input*::

   $ cat spec.pltl | black solve -
   SAT

   $ cat unsat-spec.pltl | black solve -
   UNSAT

This is useful when the formulas are generated by other programs.

Alternatively, we may give the formulas on the command line with the
``-f`` option::

   $ black solve -f '!p & X !p & F p'
   SAT

   $ black solve -f 'p & G(p -> q) & !q'
   UNSAT

.. tip::

   Formulas usually contain spaces so they have to be quoted. Moreover, they 
   usually contain many symbols which have special meaning for the shell, 
   therefore it is recommended to use single quotes (``'like this'``) rather 
   than double quotes (``"not this"``) to tell the shell to not interpret the 
   quoted contents.

.. topic:: Design choice
   
   Note how ``black``'s output is so short and terse. By default, the tool only 
   shows its result and quits, without any other information of any sort. This 
   behavior is useful when calling ``black`` from shell scripts or from other 
   programs: there is no need to parse complex logs of information to 
   understand the result.

Satisfiable formulas can correspond *e.g.*, to bugged specifications or planning
problems that admit a solution plan. In these cases, one may want to obtain the
counter-example showing the bug or the solution plan to the planning problem. 
To do this, we can ask ``black`` to print the *model* of a satisfiable formula 
with the ``-m`` option::

   $ black solve -m -f '!p & X !p & F p'
   SAT
   Model:
   - t = 0: {￢p}
   - t = 1: {￢p}
   - t = 2: {p} ⬅︎ loops here

By default, ``black`` solves formulas with the *infinite trace* semantics (see
:doc:`logics`). So here it is telling us that the model of the formula starts
with two states at ``t=0`` and ``t=1`` where ``p`` does *not* hold, followed by
a state where ``p`` holds, and then the model infinitely loops through this last
state. LTL models always loop in this way. 

If, instead, we want to interpret the formula over *finite* traces, we can tell 
so to ``black`` by passing the ``--finite`` option::

   $ black solve --finite -m -f '!p & X !p & F p'
   SAT
   Finite model:
   - t = 0: {￢p}
   - t = 1: {￢p}
   - t = 2: {p}

Note that the model does not loop anymore, but ends at ``t=2``.

Complex specifications may have huge and complex models, and we probably want to
process the output model with other scripts or programs. In this case, we need
``black`` to print the model in a more easily parsable format. The ``-o`` option
lets us choose the output format. Currently supported formats are ``readable``
(the default, that we saw above), or ``json``::

   $ black solve -o json -m -f '!p & X !p & F p'
   {
      "result": "SAT",
      "k": 1,
      "model": {
         "size": 3,
         "loop": 2,
         "states": [
            {
               "p": "false"
            },
            {
               "p": "false"
            },
            {
               "p": "true"
            }
         ]
      }
   }

.. tip:: 

   If you need to parse ``black``'s output from shell scripts or from the 
   command-line, consider using the ``json`` output format and the 
   `jq <https://stedolan.github.io/jq/>`_ command-line JSON manipulation tool.